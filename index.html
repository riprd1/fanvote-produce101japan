<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>投票（11人）</title>
  <style>
    :root{
      --bd:#e6e6e6;
      --bg:#fafafa;
      --txt:#111;
      --sub:#666;
      --pill:#f2f2f2;
    }
    body{
      font-family: system-ui, -apple-system, sans-serif;
      margin: 16px;
      color: var(--txt);
      background: #fff;
    }
    h1{font-size:18px;margin:0 0 10px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{background:var(--pill);padding:6px 10px;border-radius:999px;font-size:12px}
    .btn{
      padding:10px 12px;border:1px solid var(--bd);
      border-radius:12px;background:#fff;font-weight:800;cursor:pointer;
    }
    .btn.primary{background:#111;color:#fff;border-color:#111}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    input[type="text"]{
      padding:10px 12px;border:1px solid var(--bd);
      border-radius:12px;min-width:180px;flex:1;
    }

    /* ===== 上：選択11人 ===== */
    .selectedWrap{
      border:1px solid var(--bd);
      border-radius:16px;
      padding:12px;
      background: var(--bg);
    }
    .selectedTitle{
      font-weight:900;
      font-size:13px;
      margin:0 0 8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .selectedCount{font-weight:900}
    .slots{
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding-bottom:6px;
      -webkit-overflow-scrolling: touch;
    }
    .slot{
      flex:0 0 auto;
      width:54px;height:54px;
      border-radius:16px;
      border:2px dashed #cfcfcf;
      background:#fff;
      display:grid;
      place-items:center;
      color:#9a9a9a;
      font-weight:900;
      position:relative;
    }
    .slot.filled{
      border-style:solid;
      border-color:#dcdcdc;
      padding:0;
      overflow:hidden;
    }
    .slot img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      background:#f2f2f2;
    }
    .slot .x{
      position:absolute;
      top:-8px; right:-8px;
      width:24px;height:24px;
      border-radius:999px;
      background:#111;
      color:#fff;
      display:grid;
      place-items:center;
      font-size:14px;
      cursor:pointer;
      border:2px solid #fff;
    }

    /* ===== 中：一覧ラベル ===== */
    .listHeader{
      margin-top:14px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .listHeader h2{
      margin:0;
      font-size:14px;
      font-weight:900;
    }
    .sub{color:var(--sub);font-size:12px}

    /* ===== 下：2列グリッド ===== */
    .grid{
      margin-top:10px;
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
    }
    .card{
      border:1px solid var(--bd);
      border-radius:16px;
      padding:10px;
      background:#fff;
      display:flex;
      gap:10px;
      align-items:center;
      min-height:72px;
    }
    .avatar{
      width:54px;height:54px;
      border-radius:16px;
      overflow:hidden;
      flex:0 0 auto;
      background:#f2f2f2;
    }
    .avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .info{min-width:0}
    .name{
      font-weight:900;
      font-size:13px;
      line-height:1.2;
      word-break:break-word;
    }
    .meta{font-size:12px;color:var(--sub);margin-top:2px}
    .pick{
      margin-left:auto;
      width:22px;height:22px;
      border-radius:6px;
      border:1px solid #cfcfcf;
      display:grid;
      place-items:center;
      font-weight:900;
      flex:0 0 auto;
    }
    .picked .pick{
      background:#111;
      color:#fff;
      border-color:#111;
    }
    .picked{
      outline:2px solid rgba(0,0,0,.08);
    }

    /* 画面が狭い時でも2列維持しつつ見やすく */
    @media (max-width: 340px){
      .grid{grid-template-columns: 1fr;}
    }
  </style>
</head>

<body>
  <h1>投票（1回で11人選択）</h1>

  <div class="row" style="margin: 8px 0 12px;">
    <button id="toggleBtn" class="btn">練習生候補を表示</button>
    <input id="search" type="text" placeholder="Search（名前/英字/ID）">
    <span class="pill" id="modePill">表示：練習生</span>
  </div>

  <div class="selectedWrap">
    <div class="selectedTitle">
      <span>選択中</span>
      <span class="selectedCount"><span id="count">0</span>/11</span>
    </div>
    <div class="slots" id="slots"></div>

    <div class="row" style="margin-top:10px;">
      <button id="clearBtn" class="btn">リセット</button>
      <button id="undoBtn" class="btn">1人戻す</button>
      <button id="voteBtn" class="btn primary" disabled>11人選んで投票</button>
    </div>
    <div class="sub" style="margin-top:6px;">
      ※上の顔をタップで削除できます
    </div>
  </div>

  <div class="listHeader">
    <h2>一覧（押して追加）</h2>
    <span class="sub" id="resultCount"></span>
  </div>

  <div class="grid" id="grid"></div>

<script>
/* ====== あなたのデータをここにそのまま貼る ====== */
const traineesOnly = [
  // ← あなたが貼った121人のうち「練習生」配列をそのまま
];

const candidates = [
  // ← あなたが貼った「練習生候補」配列をそのまま
];
/* ====== ここまで ====== */

const MAX = 11;

// UI elements
const toggleBtn = document.getElementById("toggleBtn");
const modePill  = document.getElementById("modePill");
const searchEl  = document.getElementById("search");
const gridEl    = document.getElementById("grid");
const slotsEl   = document.getElementById("slots");
const countEl   = document.getElementById("count");
const voteBtn   = document.getElementById("voteBtn");
const clearBtn  = document.getElementById("clearBtn");
const undoBtn   = document.getElementById("undoBtn");
const resultCountEl = document.getElementById("resultCount");

// state
let showCandidates = false;     // URL触った時は練習生 = false
let selected = [];              // 選択順を保持（undo用）
let selectedSet = new Set();    // 高速判定
let lastActionStack = [];       // undo用（idを積む）

// 合体データ
const trainees = traineesOnly.map(x => ({...x, group:"trainee"}));
const candis   = candidates.map(x => ({...x, group:"candidate"}));

// ID参照
const byId = new Map([...trainees, ...candis].map(x => [x.id, x]));

// ==== scroll位置保持（「勝手に上に戻らない」対策の決定版）====
function preserveScroll(fn){
  const y = window.scrollY;
  fn();
  // 次の描画後に戻す（体感のズレ防止）
  requestAnimationFrame(() => window.scrollTo(0, y));
}

// ==== 表示モード ====
function currentList(){
  return showCandidates ? candis : trainees;
}

function setModeUI(){
  modePill.textContent = showCandidates ? "表示：練習生候補" : "表示：練習生";
  toggleBtn.textContent = showCandidates ? "練習生を表示" : "練習生候補を表示";
}

// ==== 上の11枠 ====
function renderSlots(){
  slotsEl.innerHTML = "";
  for(let i=0;i<MAX;i++){
    const id = selected[i];
    const slot = document.createElement("div");
    slot.className = "slot" + (id ? " filled" : "");
    if(id){
      const t = byId.get(id);
      slot.innerHTML = `
        <img src="${t?.img || ""}" alt="">
        <div class="x" data-remove="${id}">×</div>
      `;
    } else {
      slot.textContent = "+";
    }
    slotsEl.appendChild(slot);
  }
}

// slot remove (tap ×)
slotsEl.addEventListener("click", (e) => {
  const btn = e.target.closest("[data-remove]");
  if(!btn) return;
  const id = btn.getAttribute("data-remove");
  removeSelected(id);
});

// ==== 一覧（2列） ====
// ※「選んだ瞬間に上へ戻る」原因は “全部再描画” が多いこと。
// とはいえフィルタやモード切替では再描画が必要なので
// preserveScroll() でスクロール位置を完全保持します。
function renderGrid(){
  const q = searchEl.value.trim().toLowerCase();
  const list = currentList().filter(t => {
    if(!q) return true;
    return (t.name || "").toLowerCase().includes(q) || (t.id || "").toLowerCase().includes(q);
  });

  resultCountEl.textContent = `${list.length}件`;

  gridEl.innerHTML = "";
  for(const t of list){
    const picked = selectedSet.has(t.id);
    const card = document.createElement("div");
    card.className = "card" + (picked ? " picked" : "");
    card.setAttribute("data-id", t.id);
    card.innerHTML = `
      <div class="avatar"><img src="${t.img}" alt=""></div>
      <div class="info">
        <div class="name">${t.name}</div>
        <div class="meta">${showCandidates ? "練習生候補" : "練習生"}</div>
      </div>
      <div class="pick">${picked ? "✓" : "+"}</div>
    `;
    gridEl.appendChild(card);
  }
}

// card click add/remove
gridEl.addEventListener("click", (e) => {
  const card = e.target.closest(".card");
  if(!card) return;
  const id = card.getAttribute("data-id");
  if(!id) return;

  preserveScroll(() => {
    if(selectedSet.has(id)){
      removeSelected(id);
    }else{
      addSelected(id);
    }
  });
});

// ==== 選択処理 ====
function addSelected(id){
  if(selectedSet.has(id)) return;
  if(selected.length >= MAX){
    alert(`最大${MAX}人までです`);
    return;
  }
  selected.push(id);
  selectedSet.add(id);
  lastActionStack.push({type:"add", id});
  updateAll();
}

function removeSelected(id){
  if(!selectedSet.has(id)) return;
  selected = selected.filter(x => x !== id);
  selectedSet.delete(id);
  lastActionStack.push({type:"remove", id});
  updateAll();
}

function undo(){
  // 直近の「操作」を戻す：addなら削除、removeなら追加
  const last = lastActionStack.pop();
  if(!last) return;
  if(last.type === "add"){
    // 追加を戻す＝削除
    selected = selected.filter(x => x !== last.id);
    selectedSet.delete(last.id);
  } else {
    // 削除を戻す＝追加（末尾に戻す）
    if(selected.length < MAX && !selectedSet.has(last.id)){
      selected.push(last.id);
      selectedSet.add(last.id);
    }
  }
  updateAll();
}

function clearAll(){
  selected = [];
  selectedSet.clear();
  lastActionStack = [];
  updateAll();
}

// ==== 更新 ====
function updateAll(){
  countEl.textContent = String(selected.length);
  voteBtn.disabled = selected.length !== MAX;
  voteBtn.textContent = (selected.length === MAX) ? "投票する" : `あと ${MAX - selected.length} 人`;

  renderSlots();
  // 一覧は “必要最小限” で更新したいが、いまは簡潔優先で再描画
  // スクロールは preserveScroll() で守られる
  renderGrid();
}

// ==== モード切替（ボタン1つでトグル） ====
toggleBtn.addEventListener("click", () => {
  preserveScroll(() => {
    showCandidates = !showCandidates;
    setModeUI();
    renderGrid();
  });
});

// ==== 検索 ====
searchEl.addEventListener("input", () => {
  preserveScroll(() => renderGrid());
});

// ==== ボタン ====
undoBtn.addEventListener("click", () => preserveScroll(() => undo()));
clearBtn.addEventListener("click", () => {
  if(!confirm("選択をリセットしますか？")) return;
  preserveScroll(() => clearAll());
});

voteBtn.addEventListener("click", () => {
  if(selected.length !== MAX) return;
  // ここに「投票送信」を後で合体できる
  const names = selected.map(id => byId.get(id)?.name || id);
  alert("投票（仮）\n\n" + names.join("\n"));
});

// 初期描画
setModeUI();
renderSlots();
renderGrid();
updateAll(); // count等を整える
</script>
</body>
</html>
